// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Oscar Ramírez - Amy Velásquez
// Proyecto 2
// 21/10/2025

/*•︶°︶•︶°︶•︶°︶• Librerías •︶°︶•︶°︶•︶°︶• */
#include <Arduino.h>
#include <stdint.h>
#include <LiquidCrystal.h>
#include <ESP32SPISlave.h>
#include <Wire.h>

/*•︶°︶•︶°︶•︶°︶• Pines •︶°︶•︶°︶•︶°︶• */

#define ledverde 4
#define ledrojo 15
#define ledazul 17

#define rs 32
#define en 33
#define d4 27
#define d5 14
#define d6 26
#define d7 13

#define pot1 35

#define I2C_DEV_ADDR 0x55
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

/*•︶°︶•︶°︶• Variables globales •︶°︶•︶°︶• */
int cont=0;
volatile float volt;
volatile uint8_t cmd;
char lastled = '-';
volatile uint32_t pote;
volatile uint16_t bt;

volatile uint32_t lastTime = 0;

//SPI
ESP32SPISlave slave;
static constexpr size_t BUFFER_SIZE = 8;
static constexpr size_t QUEUE_SIZE = 1;

uint8_t tx_buf[BUFFER_SIZE];
uint8_t rx1_buf[BUFFER_SIZE];

uint8_t valor_led;
uint16_t valor_tiempo;


/*•︶°︶•︶°︶• Prototipos •︶°︶•︶°︶• */
void control_leds(int led, int tiempo);
void onRequest();
void onReceive(int len);


void setup() {
  Serial.begin(115200);
  pinMode(pot1,INPUT);
  pinMode(ledrojo,OUTPUT);
  pinMode(ledazul,OUTPUT);
  pinMode(ledverde,OUTPUT);

  digitalWrite(ledverde, LOW);
  digitalWrite(ledrojo, LOW);
  digitalWrite(ledazul, LOW);

  lcd.begin(16,2);
  lcd.clear();


  //Para control de I2C
  Wire.onReceive(onReceive);
  Wire.onRequest(onRequest);
  Wire.begin((uint8_t)I2C_DEV_ADDR);

  //Para control de SPI
  slave.setDataMode(SPI_MODE0);
  slave.setQueueSize(QUEUE_SIZE);
  slave.begin(VSPI);

  memset(tx_buf, 0, BUFFER_SIZE);
  memset(rx1_buf, 0, BUFFER_SIZE);
}

void loop() {
  if (slave.hasTransactionsCompletedAndAllResultsReady(QUEUE_SIZE))
  {
    //Extraer datos
    valor_led = rx1_buf[0];
    valor_tiempo = (rx1_buf[2] << 8) | rx1_buf[1];

    //Debug para verificar si coinciden los bytes

    Serial.print("SPIBytes HEX: [ ");
    for(int i = 0; i < 3; i++) {
      Serial.print("0x");
      if(rx1_buf[i] < 0x10) Serial.print("0");
      Serial.print(rx1_buf[i], HEX);
      Serial.print(" ");
    }
    //Verificación de valores
    Serial.println("]");
    Serial.print("LED: ");
    Serial.print(valor_led);
    Serial.print(", Tiempo: ");
    Serial.print(valor_tiempo);
    Serial.println("ms");

    //Validar y ejecutar el comando

    if (valor_led >= 1 && valor_led <= 3 && valor_tiempo > 0) {
      Serial.println("Ejecutando comando...");  
      control_leds(valor_led, valor_tiempo);
      } else {
      Serial.println("ERROR: Comando SPI inválido");
    }

    // Limpiar buffer y re-encolar la siguiente transacción
    memset(rx1_buf, 0, BUFFER_SIZE);
    slave.queue(NULL, rx1_buf, BUFFER_SIZE);
    slave.trigger();
  }

   if (slave.hasTransactionsCompletedAndAllResultsHandled()){
        memset(rx1_buf, 0, BUFFER_SIZE);
        slave.queue(NULL, rx1_buf, BUFFER_SIZE);
        slave.trigger();
        Serial.println("ESP32 iniciado - Listo para SPI e I2C (Re-encolado de seguridad)");
    }   


  lcd.setCursor(0,0);
  lcd.print("Bit:");
  lcd.setCursor(6,0);
  lcd.print("Vol:");
  lcd.setCursor(9,1);
  lcd.print("V");
  lcd.setCursor(11,0);
  lcd.print("LED:");

  pote=analogRead(pot1);
  bt=map(pote,0,4095,0,255);
  float volt = (float)pote * (3.3f / 4095.0f);

  delay(100);

    uint32_t CurrentTime = millis();
if (CurrentTime - lastTime > 500) {
  lcd.clear();
  lcd.setCursor(0,1);
  lcd.print(bt);

  lcd.setCursor(6,1);
  lcd.print(volt);

  lcd.setCursor(14,1);
  lcd.print(lastled);

  lastTime=CurrentTime;
}

}

/*•︶°︶•︶°︶• Funciones auxiliares •︶°︶•︶°︶• */
void control_leds(int led, int tiempo)
{
  // Apagar todos los LEDs primero
  digitalWrite(ledrojo, LOW);
  digitalWrite(ledverde, LOW);
  digitalWrite(ledazul, LOW);
  // Encender LED específico
  switch(led) {
    case 1:
      digitalWrite(ledrojo, HIGH);
      lastled='R';
      break;
    case 2:
      digitalWrite(ledverde, HIGH);
      lastled='V';
      break;
    case 3:
      digitalWrite(ledazul, HIGH);
      lastled='A';
      break;
  }
  delay(tiempo);
  // Apagar después del tiempo
  digitalWrite(ledrojo, LOW);
  digitalWrite(ledverde, LOW);
  digitalWrite(ledazul, LOW); 
}

void onRequest() {
   Wire.write(bt);
   Serial.print("Enviado a Nucleo:");
   Serial.println(bt);
}

void onReceive(int len) {
  while (Wire.available()) {
    cmd=Wire.read();
    Serial.print("Medido por comando: ");
    Serial.println((char)cmd);
  }
}
